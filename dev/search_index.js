var documenterSearchIndex = {"docs":
[{"location":"anotherPage.html#The-DTSSignals-Module","page":"An other page","title":"The DTSSignals Module","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"DTSSignals","category":"page"},{"location":"anotherPage.html#DTSSignals","page":"An other page","title":"DTSSignals","text":"DTSSignals (version 0.0.2) --- An in-house module for signals processing in DTS.\n\nAuthor: FVA, all rights reserved\n\n\n\n\n\n","category":"module"},{"location":"anotherPage.html#Module-Index","page":"An other page","title":"Module Index","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"Modules = [DTSSignals]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"anotherPage.html#Detailed-API","page":"An other page","title":"Detailed API","text":"","category":"section"},{"location":"anotherPage.html","page":"An other page","title":"An other page","text":"Modules = [DTSSignals]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"anotherPage.html#DTSSignals.Signal","page":"An other page","title":"DTSSignals.Signal","text":"struct Signal\n    n::Vector{Int}\n    v::Vector{Complex}#vector of values\n    fs::Float64#sampling frequency\nend\n\nA type to encode signals, e.g. two co-indexed sequences of integer time indices  [n] and values [v]. Note that these two sequences must have the same length, and this is enforced by the constructor.\n\nIf we want to ground the signal in some sampling process, we can add a sampling frequency [fs]. If ommitted, we leave undefined, so cave canem.\n\n\n\n\n\n","category":"type"},{"location":"anotherPage.html#Base.:*-Tuple{Complex, Signal}","page":"An other page","title":"Base.:*","text":"scale(α::Complex,x::signal) -> Signal α\n\nA function to scale a signal x by a scalar α. Scalars can be ComplexF64, Float64 or even  Note that the scalar outer product can be abbreviated to nothing so we can elide it. \n\nusing Test\n@test scale(Complex(2.0),δ(0)) == δ(0) + δ(0)\n@test (2.0+0im)*δ(0) == δ(0) + δ(0)#Not yet defined.\n@test 2δ(0) == δ(0) + δ(0) == 2.0δ(0) == (2.0+0.0im) * δ(0)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.:*-Tuple{Signal, Signal}","page":"An other page","title":"Base.:*","text":"*(x::Signal, y::Signal) → Complex\n\nDot-product of two signal. In the spirit of  extending the product.\n\nxs = δ(0) + δ(4) + δ(5)\nys = δ(0) + 2δ(4) \n@test x * y == 4.0\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.:+-Tuple{Signal, Signal}","page":"An other page","title":"Base.:+","text":"add(x::Signal, y::Signal) → Signal\nx + y -> signal\n\nA function to add two signals.\n\nExample: \n\nx = δ(0) \ny = δ(5)\nw = x + y\nx = add(δ(4), w)\nusing Test\n@test w == δ(0) + δ(5)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.:==-Tuple{Signal, Signal}","page":"An other page","title":"Base.:==","text":"==(x::Signal, y::Signal) → Bool\n\nAn equality predicate for signals. We test for equality of all content.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.:∘-Tuple{Signal, Signal}","page":"An other page","title":"Base.:∘","text":"∘(x::Signal, y::Signal) → Signal\n\nHadamard product of two signals, for windowing, etc.\n\nxs = δ(0) + δ(4) + δ(5)\nys = δ(0) + 2δ(4)\n@test xs ∘ ys == δ(0) + 2δ(4)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.conj-Tuple{Signal}","page":"An other page","title":"Base.conj","text":"conj(x::Signal) → Signal\n\nA function to generate the conjugate of a signal.\n\ns = δ(0)\nr = conj(s)\nusing Test\n@test !isreal(s.v) || x == r#only true for real signals.\n@test s == conj(r)## Always true since conj is an involution.\n@test (π/4)s != conj((π/4)s)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.imag-Tuple{Signal}","page":"An other page","title":"Base.imag","text":"imag(x::Signal) → Signal\n\nA function to obtain the imaginary part of a signal.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.isreal-Tuple{Signal}","page":"An other page","title":"Base.isreal","text":"isreal(x::Signal) → Bool\n\nA predicate to check if a signal is real.\n\nusing Test\n@test isreal(Signal([1,2,3],[1.0,2.0,3.0])) && isreal(δ(0))\n@test !isreal(Signal([1,2,3],[1.0,2.0,3.0im]))\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.length-Tuple{Signal}","page":"An other page","title":"Base.length","text":"length(x::Signal) → Integer\n\nA primitive to observe the lenth of a signal\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.real-Tuple{Signal}","page":"An other page","title":"Base.real","text":"real(x::Signal) → Signal\n\nA function to obtain the real part of a signal.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#Base.zero-Tuple{Any}","page":"An other page","title":"Base.zero","text":"zero(Signal) → Signal\n\nThe additive zero of signals. It is also the convolutive zero.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.:⊛-Tuple{Signal, Signal}","page":"An other page","title":"DTSSignals.:⊛","text":"  convolve(x::Signal, y::Signal)::Signal\n\nA primitive to convolve two signals. Example:\n\nx = δ(2)\ny = δ(5)\n@assert conv(x,y) == δ(7) == x ⊛ y\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.convolve2-Tuple{Signal, Signal}","page":"An other page","title":"DTSSignals.convolve2","text":"Another implementation, using matrix multiplication, unexported.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.sample-Tuple{Function, AbstractFloat, Integer}","page":"An other page","title":"DTSSignals.sample","text":"sample(f::Function, fs::AbstractFloat, N::Integer) → Signal\n\nA function to sample a time function [f] at a given sampling frequency  [fs] for [N] samples.\n\nusing Test\nx = sample(t -> sin(2π*t), 1.0, 10)\n@test length(x.n) == 10\n@test x.v  == collect(0:9)\n@test x.v ≈ sin.(2π*collect(0:9))\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.shift-Tuple{Signal, Integer}","page":"An other page","title":"DTSSignals.shift","text":"shift(x::signal, τ::Integer ) -> signal\n\nA function to implement a time displacement (positive delay).\n\nExample:\n\n@assert shift(δ(0), 4) == δ(4)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.sinusoid-NTuple{4, Real}","page":"An other page","title":"DTSSignals.sinusoid","text":"sinusoid(A, f, φ, t) → Real\n\nA function to generate a real sinusoid with its standard parameters:\n\nA: amplitude, dimensionless. \nf: frequency in Hz. \nφ: phase, in radians.\nt: time in seconds. \n\nNote that the sinusoid is generated with a cosine function.\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.trim-Tuple{Vector, Vector}","page":"An other page","title":"DTSSignals.trim","text":"trim(t, v) → (trimmedt,trimmedv)\n\nA function to trim away the zeros of a value vector  on the left and the right, and co-indexed time scale. This allows some sparsity in the representation of signals with a finite number of non-zero values. \n\nUse example: \n\nn = collect(-3:3);\nv = Vector{Float64}zeros(length(t)); \nv[2] = 1.0;#This is the value of a delta at n=-2, δ(n + 2)\n(trimmedt, trimmedv) = trim(n,v)\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.visualise!-Tuple{Signal}","page":"An other page","title":"DTSSignals.visualise!","text":"visualise!(x::signal)\n\nA primitive to visualise a DT signal as a stem plot:\n\nThe default is to visualize the real component\nIf \"full\" visualization is requested the default is polar\nFor real vs. imaginary part use full=true, polar=false\n\nn = collect(-3:3)\nv = Complex.([0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0])\n#v = map(Complex, [0.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0])\nx = Signal(n,v; doTrim = false)#The N=3 pulse\nf = Figure()\n#Axis(f[1,1])\nvisualise!(x)\nAxis(f[end+1,1])\nvisualise!(x;full=true)\nAxis(f[end+1,1])\nvisualise!(x;full=true,polar=false)\nf\n\n\n\n\n\n","category":"method"},{"location":"anotherPage.html#DTSSignals.δ-Tuple{Integer}","page":"An other page","title":"DTSSignals.δ","text":"δ(τ::Integer) → Signal\n\nA function to generate a delta signal at a shift of τ.\n\nExample:\n\nδ(5)\n\n\n\n\n\n","category":"method"},{"location":"index.html#DTSSignals.jl","page":"Index","title":"DTSSignals.jl","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"Documentation for DTSSignals.jl.","category":"page"}]
}
